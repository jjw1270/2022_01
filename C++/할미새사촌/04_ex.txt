①    (   &   ) 연산자는 변수의 주소를 추출하기위해 사용한다. (앰퍼샌드연산자)

②    동적으로 할당된 메모리를 반환하고자 할 때는 (   delete   ) 연산자를 사용한다.

③    (   new   ) 연산자는 할당되는 동적 메모리의 시작 주소를 반환한다.

④    동적으로 할당되는 메모리는 (   힙   ) 영역에 할당 받는 메모리이다.

⑤    new를 이용하여 할당 받은 메모리를 해제 할 때에는 (   delete   )를 사용한다.

⑥    객체 포인터로 멤버를 접근할 때에는 (   ->   ) 연산자를 사용한다.

⑦    (   nullptr   )은 null pointer를 의미하는 것으로 NULL 매크로 사용시 함수 매개변수로 전달하는 경우 int타입으로 추론되는 문제점을 해결할 수 있다.

⑧    new 연산자를 사용하여 객체를 동적으로 할당할 때 (   생성자   )가 호출된다.

⑨    동적으로 할당 된 객체 소멸 시 (   소멸자   )가 호출된다.

⑩    함수 선언 시 (   const   )를 사용하면 멤버 변수의 값을 변경할 수 없다.

⑪    스마트 포인터 중 (   unique_ptr   )는 포인터를 공유할 수 없다.

⑫    스마트 포인터를 사용하려면 (   <memory>   ) 헤더 파일이 필요하다.

2. 
1)X new연산자를 사용
2)X틀림 -> O 그냥 단순하게 바로 선언해서 배열을 동적할당 시 초기화 할 수 없다. 다른상황에서는 가능
3)X 반환순서는 생성순서와 거꾸로 간다
4)O
5)X
6) X
7)delte는 동적 할당메모리해제시에만 X
8)O
9)O
10)O 쉐어드_PTR
11)O 스마트 포인터 메모리 누수 방지 위해 사용/ ***나는 친구를 친구는 나를 가리킬때 메모리 누수 발생 가능 -> weak_ptr사용시 누수발생x
12)X this 는 클래스의 멤버 함수 내에서만 사용 -> 지역에서 사용
13)O static은 지역바깥에도 사용되서 지역만 사용하는 this는 x
14)X this는 컴파일러가 삽입해주는 지역변수이다
15)O 스마트포인터 매개변수로 전달 가능

3.
1)Rec *p
2)p = &r
3)p -> write, (*p).write()
4)Rec *arr = new Rec[4]
5)Rec *arr = make_unique<Rec[]>(4) == auto arr=make_unique<Rec[]>(4)
== unique_ptr<Rec> arr = make_unique<Rec[]>(4)
6)delete [] arr;
7)arr[1]->write(); 틀림 , (arr+1)->write();,  (*(arr+1)).write()
8)Rec *dim = new Rec[3]{ Rec(1,2) }
9)for(auto a : array){ a.write() }

4. 20
5. 7, 15
6. 스마트포인터 종류
unique_ptr
shared_ptr
weak_ptr

7.
8.
9.
10.
pizza 객체 배열 new를 이용하여 동적배열 생성 -> 동적생성이므로 반드시 delete

